# Aslet

Aslet is an asynchronous SQLite interface for Godot. It provides a non-blocking
API designed primarily for servers, which is critical in game development where
the main thread must always be responsive. This design ensures all database
operations execute off-thread, maintaining server stability and performance.

## Limitations

- Read-only databases in `res://` cannot be opened in released Godot projects.\
  They work normally in the editor. A common workaround in release builds is
  copying the database from `res://` to `user://` on the first run.
- The library is focused on server-side usage, not on client applications.
- It is not possible to create custom SQLite functions from GDScript\
  since all database operations are executed in a separate thread.

## Async Operations

All Aslet operations are async. Every call returns an `AsletTask`.\
In GDScript, you can `await` the task's `done` signal to get the result array,
which has the format:

[status, ...results]

- `status` is either `OK` or `FAILED`.
- `results` depends on the operation (e.g., a connection object, fetched rows,
  error code and message).

## Example

```gdscript
extends Control


var aslet: Aslet


func _init() -> void:
    aslet = Aslet.new()


func _ready() -> void:
    # every async call returns [OK|FAILED, ...]
    var result := await aslet.open('user://users.db').done as Array
    assert(result[0] == OK)

    var db := result[1] as AsletConn
    await db.exec("create table if not exists users (id integer primary key, name text)", []).done
    await db.exec("insert into users (name) values ('Alice')", []).done

    # each inner array represents the parameters for a single row
    var names := [['A'], ['B'], ['C'], ['D'], ['E']]
    result = await db.batch_insert('insert into users (name) values (?1)', names).done
    assert(result[0] == OK)

    # the third value of the return from fetch is a PackedStringArray
    # containing all queried column names
    result = await db.fetch("select * from users", []).done
    assert(result[2] == PackedStringArray(['id', 'name']))
    var rows := result[1] as Array
    for row in rows:
        print(row[0], row[1])

    # transactions are independent/isolated
    var tx = (await db.transaction().done)[1] as AsletTransaction
    await tx.exec('insert into users (name) values (?1)', ['hello world']).done
    await tx.commit().done

    # once committed or rolled back, a transaction becomes invalid
    result = await tx.exec('insert into users (name) values (?1)', ['hello world again']).done
    assert(result[0] == FAILED && result[1] == 10001)

    # incremental backup with progress callback
    # copies the database in chunks (10 pages per tick)
    var on_tick := func(page_count: int, remaining: int):
        print('tick %d / %d' % [page_count - remaining, page_count])
    result = await db.backup('user://users2.db', 10, on_tick).done
    assert(result[0] == OK)


func _process(_dt: float) -> void:
    # small timeout means less impact on the main thread and slower task handling
    aslet.poll(5)
```

## Error Codes and Ranges

- SQLite error codes are preserved.
- (10000 - 10999): Aslet internal errors.
- (12000 - 12999): Rusqlite errors.

### Aslet and `rusqlite` Specific Error Codes

Beyond the standard SQLite error codes, Aslet defines additional codes for
internal issues and specific `rusqlite` failures that do not have direct SQLite
integer codes. These codes are returned as the `code` value in a
`[FAILED, code, errmsg]` array.

### Aslet Internal Errors (Range: 10000 - 10999)

These errors indicate issues within the Aslet GDExtension's internal logic.

| Code  | Variant              | Description                                                                                                                  |
| :---- | :------------------- | :--------------------------------------------------------------------------------------------------------------------------- |
| 10001 | `InvalidConnection`  | An operation was attempted with an invalid or closed connection ID. The error message will typically include the invalid ID. |
| 10002 | `InvalidTransaction` | An operation (commit/rollback) was attempted on a transaction that is no longer active or valid.                             |

### `rusqlite` Specific Errors (Range: 12000 - 12999)

These codes are generated by the `rusqlite` library for conditions that are not
direct SQLite error codes.

| Code  | Variant                       | Description                                                                                               |
| :---- | :---------------------------- | :-------------------------------------------------------------------------------------------------------- |
| 12001 | `SqliteFailure`               | Generic `rusqlite` failure not covered by standard SQLite codes (often includes underlying SQLite error). |
| 12002 | `SqliteSingleThreadedMode`    | Attempted multi-threaded access while `rusqlite` is in single-threaded mode.                              |
| 12003 | `FromSqlConversionFailure`    | Failed to convert a SQLite value to the requested Rust type.                                              |
| 12004 | `IntegralValueOutOfRange`     | An integer value from SQLite was out of range for the target Rust type.                                   |
| 12005 | `Utf8Error`                   | A string from SQLite was not valid UTF-8.                                                                 |
| 12006 | `NulError`                    | An attempt to create a C string from a Rust string failed due to an embedded null byte.                   |
| 12007 | `InvalidParameterName`        | An SQL parameter name (e.g., `:param`) was invalid.                                                       |
| 12008 | `InvalidPath`                 | An invalid file path was provided for a database.                                                         |
| 12009 | `ExecuteReturnedResults`      | `execute` was called on a statement that returned results (e.g., `SELECT`).                               |
| 12010 | `QueryReturnedNoRows`         | A query expected at least one row but returned none.                                                      |
| 12011 | `QueryReturnedMoreThanOneRow` | A query expected a single row but returned more than one.                                                 |
| 12012 | `InvalidColumnIndex`          | Attempted to access a column by an invalid index.                                                         |
| 12013 | `InvalidColumnName`           | Attempted to access a column by an invalidname.                                                           |
| 12014 | `InvalidColumnType`           | The column's type did not match the expected type during retrieval.                                       |
| 12015 | `StatementChangedRows`        | `query` was called on a statement that changed rows (e.g., `INSERT`).                                     |
| 12016 | `ToSqlConversionFailure`      | Failed to convert a Rust value to a SQLite value for binding.                                             |
| 12017 | `InvalidQuery`                | The SQL query provided was invalid.                                                                       |
| 12018 | `UnwindingPanic`              | A panic occurred in a callback from SQLite.                                                               |
| 12019 | `MultipleStatement`           | Attempted to prepare multiple SQL statements in a single string.                                          |
| 12020 | `InvalidParameterCount`       | The number of bound parameters did not match the number of parameters in the query.                       |
| 12021 | `SqlInputError`               | Generic SQL input error (e.g., from `NO_ROW_LEFT_TO_QUERY`).                                              |
| 12022 | `InvalidDatabaseIndex`        | An invalid database index was provided.                                                                   |
| 12999 | `_`                           | An unknown or unhandled `rusqlite` error variant.                                                         |

## Philosophy & Governance

### Development Model

Aslet follows a cathedral-style development model. The project does not accept
external code contributions or pull requests.

This decision is intentional and aims to preserve architectural coherence,
predictability, and long-term maintainability.

### Continuity and User Freedom

Aslet is licensed under the MIT License. Users are free to fork, modify, and
maintain their own versions independently.

The codebase is written to be idiomatic and self-explanatory to support this
model without reliance on upstream involvement.
